diff --git a/src/acpi.c b/src/acpi.c
index ce988e0..1994838 100644
--- a/src/acpi.c
+++ b/src/acpi.c
@@ -18,6 +18,8 @@
 
 #include "acpi-dsdt.hex"
 
+u32 acpi_pm1a_cnt VARFSEG;
+
 static void
 build_header(struct acpi_table_header *h, u32 sig, int len, u8 rev)
 {
@@ -86,9 +88,9 @@ void ich9_lpc_fadt_setup(struct pci_device *dev, void *arg)
     fadt->gpe0_blk_len = ICH9_PMIO_GPE0_BLK_LEN;
     fadt->plvl2_lat = cpu_to_le16(0xfff); // C2 state not supported
     fadt->plvl3_lat = cpu_to_le16(0xfff); // C3 state not supported
-    /* WBINVD + PROC_C1 + SLP_BUTTON + FIX_RTC + RTC_S4 */
-    fadt->flags = cpu_to_le32((1 << 0) | (1 << 2) | (1 << 5) | (1 << 6) |
-                              (1 << 7));
+    /* WBINVD + PROC_C1 + SLP_BUTTON + RTC_S4 + USE_PLATFORM_CLOCK */
+    fadt->flags = cpu_to_le32((1 << 0) | (1 << 2) | (1 << 5) | (1 << 7) |
+                              (1 << 15));
 }
 
 static const struct pci_device_id fadt_init_tbl[] = {
@@ -730,9 +732,12 @@ find_acpi_features(void)
     if (!fadt)
         return;
     u32 pm_tmr = le32_to_cpu(fadt->pm_tmr_blk);
+    u32 pm1a_cnt = le32_to_cpu(fadt->pm1a_cnt_blk);
     dprintf(4, "pm_tmr_blk=%x\n", pm_tmr);
     if (pm_tmr)
         pmtimer_setup(pm_tmr, 3579);
+    if (pm1a_cnt)
+        acpi_pm1a_cnt = pm1a_cnt;
 
     // Theoretically we should check the 'reset_reg_sup' flag, but Windows
     // doesn't and thus nobody seems to *set* it. If the table is large enough
diff --git a/src/acpi.h b/src/acpi.h
index 5d1e104..f0d24d4 100644
--- a/src/acpi.h
+++ b/src/acpi.h
@@ -36,6 +36,7 @@ struct rsdp_descriptor {        /* Root System Descriptor Pointer */
 };
 
 extern struct rsdp_descriptor *RsdpAddr;
+extern u32 acpi_pm1a_cnt;
 
 /* Table structure from Linux kernel (the ACPI tables are under the
    BSD license) */
diff --git a/src/ahci.c b/src/ahci.c
index 879a991..f2cc71b 100644
--- a/src/ahci.c
+++ b/src/ahci.c
@@ -381,12 +381,26 @@ ahci_port_alloc(struct ahci_ctrl_s *ctrl, u32 pnr)
     return port;
 }
 
+static void ahci_port_release(struct ahci_port_s *port)
+{
+    ahci_port_reset(port->ctrl, port->pnr);
+    free(port->list);
+    free(port->fis);
+    free(port->cmd);
+    free(port);
+}
+
 static struct ahci_port_s* ahci_port_realloc(struct ahci_port_s *port)
 {
     struct ahci_port_s *tmp;
     u32 cmd;
 
     tmp = malloc_fseg(sizeof(*port));
+    if (!tmp) {
+        warn_noalloc();
+        ahci_port_release(port);
+        return NULL;
+    }
     *tmp = *port;
     free(port);
     port = tmp;
@@ -410,15 +424,6 @@ static struct ahci_port_s* ahci_port_realloc(struct ahci_port_s *port)
     return port;
 }
 
-static void ahci_port_release(struct ahci_port_s *port)
-{
-    ahci_port_reset(port->ctrl, port->pnr);
-    free(port->list);
-    free(port->fis);
-    free(port->cmd);
-    free(port);
-}
-
 #define MAXMODEL 40
 
 /* See ahci spec chapter 10.1 "Software Initialization of HBA" */
@@ -554,6 +559,8 @@ ahci_port_detect(void *data)
         ahci_port_release(port);
     else {
         port = ahci_port_realloc(port);
+        if (port == NULL)
+            return;
         dprintf(1, "AHCI/%d: registering: \"%s\"\n", port->pnr, port->desc);
         if (!port->atapi) {
             // Register with bcv system.
diff --git a/src/apm.c b/src/apm.c
index b2eac6d..de6bd99 100644
--- a/src/apm.c
+++ b/src/apm.c
@@ -12,6 +12,7 @@
 #include "config.h" // CONFIG_*
 #include "biosvar.h" // GET_GLOBAL
 #include "paravirt.h" // runningOnQEMU
+#include "acpi.h" // acpi_pm_ctl
 
 static void
 out_str(const char *str_cs)
@@ -108,7 +109,11 @@ handle_155306(struct bregs *regs)
 void
 apm_shutdown(void)
 {
+    u16 pm1a_cnt = GET_GLOBAL(acpi_pm1a_cnt);
+
     irq_disable();
+    if (pm1a_cnt)
+        outw(0x2000, pm1a_cnt);
     out_str("Shutdown");
     for (;;)
         hlt();
diff --git a/src/coreboot.c b/src/coreboot.c
index 6ad4cfc..c70e8aa 100644
--- a/src/coreboot.c
+++ b/src/coreboot.c
@@ -375,7 +375,7 @@ coreboot_cbfs_init(void)
         }
         romfile_add(&cfile->file);
 
-        fhdr = (void*)ALIGN((u32)cfile->data + cfile->file.size
+        fhdr = (void*)ALIGN((u32)cfile->data + cfile->rawsize
                             , be32_to_cpu(hdr->align));
     }
 }
diff --git a/src/pci.c b/src/pci.c
index 6163a29..dc62c5c 100644
--- a/src/pci.c
+++ b/src/pci.c
@@ -122,6 +122,7 @@ pci_probe_devices(void)
             }
             memset(dev, 0, sizeof(*dev));
             hlist_add(&dev->node, pprev);
+            pprev = &dev->node.next;
             count++;
 
             // Find parent device.
diff --git a/src/pciinit.c b/src/pciinit.c
index 8370b96..0c6b0cb 100644
--- a/src/pciinit.c
+++ b/src/pciinit.c
@@ -15,6 +15,7 @@
 #include "paravirt.h" // RamSize
 #include "dev-q35.h" // Q35_HOST_BRIDGE_PCIEXBAR_ADDR
 #include "list.h" // struct hlist_node
+#include "acpi.h" // acpi_pm1a_cnt
 
 /* PM Timer ticks per second (HZ) */
 #define PM_TIMER_FREQUENCY  3579545
@@ -194,6 +195,7 @@ void mch_isa_bridge_setup(struct pci_device *dev, void *arg)
     /* acpi enable, SCI: IRQ9 000b = irq9*/
     pci_config_writeb(bdf, ICH9_LPC_ACPI_CTRL, ICH9_LPC_ACPI_CTRL_ACPI_EN);
 
+    acpi_pm1a_cnt = PORT_ACPI_PM_BASE + 0x04;
     pmtimer_setup(PORT_ACPI_PM_BASE + 0x08, PM_TIMER_FREQUENCY / 1000);
 }
 
@@ -238,6 +240,7 @@ static void piix4_pm_setup(struct pci_device *pci, void *arg)
     pci_config_writel(bdf, 0x90, PORT_SMB_BASE | 1);
     pci_config_writeb(bdf, 0xd2, 0x09); /* enable SMBus io space */
 
+    acpi_pm1a_cnt = PORT_ACPI_PM_BASE + 0x04;
     pmtimer_setup(PORT_ACPI_PM_BASE + 0x08, PM_TIMER_FREQUENCY / 1000);
 }
 
diff --git a/src/usb.c b/src/usb.c
index ecccd75..42541ff 100644
--- a/src/usb.c
+++ b/src/usb.c
@@ -444,7 +444,7 @@ usb_setup(void)
                 }
                 if (ehcipci->class == PCI_CLASS_SERIAL_USB)
                     found++;
-                ehcipci = container_of(
+                ehcipci = container_of_or_null(
                     ehcipci->node.next, struct pci_device, node);
                 if (!ehcipci || (pci_bdf_to_busdev(ehcipci->bdf)
                                  != pci_bdf_to_busdev(pci->bdf)))
diff --git a/tools/buildversion.sh b/tools/buildversion.sh
index c8c1725..e5ce96c 100755
--- a/tools/buildversion.sh
+++ b/tools/buildversion.sh
@@ -4,7 +4,7 @@ OUTFILE="$1"
 VAR16MODE="$2"
 
 # Extract version info
-if [ -d .git ]; then
+if [ -d .git -o -f .git ]; then
     VERSION="`git describe --tags --long --dirty`"
 elif [ -f .version ]; then
     VERSION="`cat .version`"
